/* Model.c generated by valac 0.10.0, the Vala compiler
 * generated from Model.vala, do not modify */

/* Application.vala
 *
 * Copyright (C) 2010  Joel Marty
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *  
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Author:
 * 	Joel Marty <10093745@brookes.ac.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>


#define GNOMECOOK_MODEL_TYPE_MODEL (gnomecook_model_model_get_type ())
#define GNOMECOOK_MODEL_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_MODEL_TYPE_MODEL, gnomecookmodelModel))
#define GNOMECOOK_MODEL_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMECOOK_MODEL_TYPE_MODEL, gnomecookmodelModelClass))
#define GNOMECOOK_MODEL_IS_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_MODEL_TYPE_MODEL))
#define GNOMECOOK_MODEL_IS_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMECOOK_MODEL_TYPE_MODEL))
#define GNOMECOOK_MODEL_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMECOOK_MODEL_TYPE_MODEL, gnomecookmodelModelClass))

typedef struct _gnomecookmodelModel gnomecookmodelModel;
typedef struct _gnomecookmodelModelClass gnomecookmodelModelClass;
typedef struct _gnomecookmodelModelPrivate gnomecookmodelModelPrivate;

#define GNOMECOOK_DAO_TYPE_MEAL_DAO (gnomecook_dao_meal_dao_get_type ())
#define GNOMECOOK_DAO_MEAL_DAO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAO))
#define GNOMECOOK_DAO_MEAL_DAO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAOClass))
#define GNOMECOOK_DAO_IS_MEAL_DAO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO))
#define GNOMECOOK_DAO_IS_MEAL_DAO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMECOOK_DAO_TYPE_MEAL_DAO))
#define GNOMECOOK_DAO_MEAL_DAO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAOClass))

typedef struct _gnomecookDAOMealDAO gnomecookDAOMealDAO;
typedef struct _gnomecookDAOMealDAOClass gnomecookDAOMealDAOClass;

#define GNOMECOOK_DOMAIN_TYPE_MEAL (gnomecook_domain_meal_get_type ())
#define GNOMECOOK_DOMAIN_MEAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMeal))
#define GNOMECOOK_DOMAIN_MEAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMealClass))
#define GNOMECOOK_DOMAIN_IS_MEAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL))
#define GNOMECOOK_DOMAIN_IS_MEAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMECOOK_DOMAIN_TYPE_MEAL))
#define GNOMECOOK_DOMAIN_MEAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMealClass))

typedef struct _gnomecookDomainMeal gnomecookDomainMeal;
typedef struct _gnomecookDomainMealClass gnomecookDomainMealClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GNOMECOOK_DAO_TYPE_DAO_INTERFACE (gnomecook_dao_dao_interface_get_type ())
#define GNOMECOOK_DAO_DAO_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE, gnomecookDAODAOInterface))
#define GNOMECOOK_DAO_IS_DAO_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE))
#define GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE, gnomecookDAODAOInterfaceIface))

typedef struct _gnomecookDAODAOInterface gnomecookDAODAOInterface;
typedef struct _gnomecookDAODAOInterfaceIface gnomecookDAODAOInterfaceIface;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _gnomecookmodelModel {
	GObject parent_instance;
	gnomecookmodelModelPrivate * priv;
};

struct _gnomecookmodelModelClass {
	GObjectClass parent_class;
};

struct _gnomecookmodelModelPrivate {
	gnomecookDAOMealDAO* dao;
	GeeList* models;
};

typedef enum  {
	GNOMECOOK_DAO_DAO_ERROR_E_OPEN,
	GNOMECOOK_DAO_DAO_ERROR_E_SQL,
	GNOMECOOK_DAO_DAO_ERROR_E_TYPE
} gnomecookDAODAOError;
#define GNOMECOOK_DAO_DAO_ERROR gnomecook_dao_dao_error_quark ()
struct _gnomecookDAODAOInterfaceIface {
	GTypeInterface parent_iface;
	gpointer (*get_one) (gnomecookDAODAOInterface* self, gint64 id, GError** error);
	GeeList* (*get_all) (gnomecookDAODAOInterface* self, GError** error);
	void (*add) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
	void (*update) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
	void (*del) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
};


static gpointer gnomecook_model_model_parent_class = NULL;

GType gnomecook_model_model_get_type (void) G_GNUC_CONST;
GType gnomecook_dao_meal_dao_get_type (void) G_GNUC_CONST;
GType gnomecook_domain_meal_get_type (void) G_GNUC_CONST;
#define GNOMECOOK_MODEL_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMECOOK_MODEL_TYPE_MODEL, gnomecookmodelModelPrivate))
enum  {
	GNOMECOOK_MODEL_MODEL_DUMMY_PROPERTY
};
gnomecookmodelModel* gnomecook_model_model_new (void);
gnomecookmodelModel* gnomecook_model_model_construct (GType object_type);
GQuark gnomecook_dao_dao_error_quark (void);
gnomecookDAOMealDAO* gnomecook_dao_meal_dao_get_instance (GError** error);
GType gnomecook_dao_dao_interface_get_type (void) G_GNUC_CONST;
GeeList* gnomecook_dao_dao_interface_get_all (gnomecookDAODAOInterface* self, GError** error);
void gnomecook_model_model_add (gnomecookmodelModel* self, gnomecookDomainMeal* m);
void gnomecook_dao_dao_interface_add (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
void gnomecook_model_model_update (gnomecookmodelModel* self, gnomecookDomainMeal* m);
void gnomecook_dao_dao_interface_update (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
GeeList* gnomecook_model_model_get_all (gnomecookmodelModel* self);
void gnomecook_model_model_del (gnomecookmodelModel* self, gnomecookDomainMeal* m);
void gnomecook_dao_dao_interface_del (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
gnomecookDomainMeal* gnomecook_model_model_get_one (gnomecookmodelModel* self, gint64 id);
gint64 gnomecook_domain_meal_get_id (gnomecookDomainMeal* self);
static void gnomecook_model_model_finalize (GObject* obj);



#line 35 "Model.vala"
gnomecookmodelModel* gnomecook_model_model_construct (GType object_type) {
#line 132 "Model.c"
	gnomecookmodelModel * self;
	GError * _inner_error_ = NULL;
#line 35 "Model.vala"
	self = (gnomecookmodelModel*) g_object_new (object_type, NULL);
#line 137 "Model.c"
	{
		gnomecookDAOMealDAO* _tmp0_;
		gnomecookDAOMealDAO* _tmp1_;
		GeeList* _tmp2_;
		GeeList* _tmp3_;
#line 38 "Model.vala"
		_tmp0_ = gnomecook_dao_meal_dao_get_instance (&_inner_error_);
#line 145 "Model.c"
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN)) {
				goto __catch0_gnomecook_dao_dao_error_e_open;
			}
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL)) {
				goto __catch0_gnomecook_dao_dao_error_e_sql;
			}
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_TYPE)) {
				goto __catch0_gnomecook_dao_dao_error_e_type;
			}
			goto __catch0_g_error;
		}
#line 38 "Model.vala"
		self->priv->dao = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->dao), _tmp1_);
#line 39 "Model.vala"
		_tmp2_ = gnomecook_dao_dao_interface_get_all ((gnomecookDAODAOInterface*) self->priv->dao, &_inner_error_);
#line 162 "Model.c"
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN)) {
				goto __catch0_gnomecook_dao_dao_error_e_open;
			}
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL)) {
				goto __catch0_gnomecook_dao_dao_error_e_sql;
			}
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_TYPE)) {
				goto __catch0_gnomecook_dao_dao_error_e_type;
			}
			goto __catch0_g_error;
		}
#line 39 "Model.vala"
		self->priv->models = (_tmp3_ = _tmp2_, _g_object_unref0 (self->priv->models), _tmp3_);
#line 177 "Model.c"
	}
	goto __finally0;
	__catch0_gnomecook_dao_dao_error_e_open:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 41 "Model.vala"
			g_debug ("Model.vala:41: error opening database!");
#line 42 "Model.vala"
			g_debug ("Model.vala:42: %s", e->message);
#line 190 "Model.c"
			_g_error_free0 (e);
		}
	}
	goto __finally0;
	__catch0_gnomecook_dao_dao_error_e_sql:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 44 "Model.vala"
			g_debug ("Model.vala:44: error loading data from db!");
#line 45 "Model.vala"
			g_debug ("Model.vala:45: %s", e->message);
#line 205 "Model.c"
			_g_error_free0 (e);
		}
	}
	goto __finally0;
	__catch0_gnomecook_dao_dao_error_e_type:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 47 "Model.vala"
			g_debug ("Model.vala:47: error loading row, invalid type!");
#line 48 "Model.vala"
			g_debug ("Model.vala:48: %s", e->message);
#line 220 "Model.c"
			_g_error_free0 (e);
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 50 "Model.vala"
			g_debug ("Model.vala:50: error: %s ", e->message);
#line 233 "Model.c"
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


#line 35 "Model.vala"
gnomecookmodelModel* gnomecook_model_model_new (void) {
#line 35 "Model.vala"
	return gnomecook_model_model_construct (GNOMECOOK_MODEL_TYPE_MODEL);
#line 251 "Model.c"
}


#line 54 "Model.vala"
void gnomecook_model_model_add (gnomecookmodelModel* self, gnomecookDomainMeal* m) {
#line 257 "Model.c"
	GError * _inner_error_ = NULL;
#line 54 "Model.vala"
	g_return_if_fail (self != NULL);
#line 54 "Model.vala"
	g_return_if_fail (m != NULL);
#line 263 "Model.c"
	{
#line 57 "Model.vala"
		if (m != NULL) {
#line 58 "Model.vala"
			gnomecook_dao_dao_interface_add ((gnomecookDAODAOInterface*) self->priv->dao, m, &_inner_error_);
#line 269 "Model.c"
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
					goto __catch1_gnomecook_dao_dao_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
#line 59 "Model.vala"
			gee_collection_add ((GeeCollection*) self->priv->models, m);
#line 280 "Model.c"
		}
	}
	goto __finally1;
	__catch1_gnomecook_dao_dao_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 62 "Model.vala"
			g_debug ("Model.vala:62: failed to add new meal: %s", e->message);
#line 292 "Model.c"
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


#line 66 "Model.vala"
void gnomecook_model_model_update (gnomecookmodelModel* self, gnomecookDomainMeal* m) {
#line 307 "Model.c"
	GError * _inner_error_ = NULL;
#line 66 "Model.vala"
	g_return_if_fail (self != NULL);
#line 66 "Model.vala"
	g_return_if_fail (m != NULL);
#line 313 "Model.c"
	{
		GeeList* _tmp0_;
#line 69 "Model.vala"
		if (m != NULL) {
#line 70 "Model.vala"
			gnomecook_dao_dao_interface_update ((gnomecookDAODAOInterface*) self->priv->dao, m, &_inner_error_);
#line 320 "Model.c"
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
					goto __catch2_gnomecook_dao_dao_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
#line 72 "Model.vala"
		self->priv->models = (_tmp0_ = gnomecook_model_model_get_all (self), _g_object_unref0 (self->priv->models), _tmp0_);
#line 332 "Model.c"
	}
	goto __finally2;
	__catch2_gnomecook_dao_dao_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 74 "Model.vala"
			g_debug ("Model.vala:74: failed to update model: %s", e->message);
#line 343 "Model.c"
			_g_error_free0 (e);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


#line 78 "Model.vala"
void gnomecook_model_model_del (gnomecookmodelModel* self, gnomecookDomainMeal* m) {
#line 358 "Model.c"
	GError * _inner_error_ = NULL;
#line 78 "Model.vala"
	g_return_if_fail (self != NULL);
#line 78 "Model.vala"
	g_return_if_fail (m != NULL);
#line 79 "Model.vala"
	g_debug ("Model.vala:79: Model.del()");
#line 366 "Model.c"
	{
#line 82 "Model.vala"
		if (m != NULL) {
#line 83 "Model.vala"
			gnomecook_dao_dao_interface_del ((gnomecookDAODAOInterface*) self->priv->dao, m, &_inner_error_);
#line 372 "Model.c"
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
					goto __catch3_gnomecook_dao_dao_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
#line 84 "Model.vala"
			gee_collection_remove ((GeeCollection*) self->priv->models, m);
#line 383 "Model.c"
		}
	}
	goto __finally3;
	__catch3_gnomecook_dao_dao_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 87 "Model.vala"
			g_debug ("Model.vala:87: failed to delete model: %s", e->message);
#line 395 "Model.c"
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 92 "Model.vala"
GeeList* gnomecook_model_model_get_all (gnomecookmodelModel* self) {
#line 415 "Model.c"
	GeeList* result = NULL;
	GeeList* _tmp0_;
	GeeList* _tmp1_;
	GError * _inner_error_ = NULL;
#line 92 "Model.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 93 "Model.vala"
	_tmp0_ = gnomecook_dao_dao_interface_get_all ((gnomecookDAODAOInterface*) self->priv->dao, &_inner_error_);
#line 424 "Model.c"
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
#line 93 "Model.vala"
	self->priv->models = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->models), _tmp1_);
#line 432 "Model.c"
	result = _g_object_ref0 (self->priv->models);
#line 94 "Model.vala"
	return result;
#line 436 "Model.c"
}


#line 97 "Model.vala"
gnomecookDomainMeal* gnomecook_model_model_get_one (gnomecookmodelModel* self, gint64 id) {
#line 442 "Model.c"
	gnomecookDomainMeal* result = NULL;
	gnomecookDomainMeal* val;
#line 97 "Model.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 99 "Model.vala"
	val = NULL;
#line 449 "Model.c"
	{
		GeeIterator* _m_it;
#line 101 "Model.vala"
		_m_it = gee_iterable_iterator ((GeeIterable*) self->priv->models);
#line 101 "Model.vala"
		while (TRUE) {
#line 456 "Model.c"
			gnomecookDomainMeal* m;
#line 101 "Model.vala"
			if (!gee_iterator_next (_m_it)) {
#line 101 "Model.vala"
				break;
#line 462 "Model.c"
			}
#line 101 "Model.vala"
			m = (gnomecookDomainMeal*) gee_iterator_get (_m_it);
#line 102 "Model.vala"
			if (gnomecook_domain_meal_get_id (m) == id) {
#line 468 "Model.c"
				gnomecookDomainMeal* _tmp0_;
#line 103 "Model.vala"
				val = (_tmp0_ = _g_object_ref0 (m), _g_object_unref0 (val), _tmp0_);
#line 472 "Model.c"
			}
			_g_object_unref0 (m);
		}
		_g_object_unref0 (_m_it);
	}
	result = val;
#line 106 "Model.vala"
	return result;
#line 481 "Model.c"
}


static void gnomecook_model_model_class_init (gnomecookmodelModelClass * klass) {
	gnomecook_model_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (gnomecookmodelModelPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnomecook_model_model_finalize;
}


static void gnomecook_model_model_instance_init (gnomecookmodelModel * self) {
	self->priv = GNOMECOOK_MODEL_MODEL_GET_PRIVATE (self);
	self->priv->dao = NULL;
	self->priv->models = NULL;
}


static void gnomecook_model_model_finalize (GObject* obj) {
	gnomecookmodelModel * self;
	self = GNOMECOOK_MODEL_MODEL (obj);
	_g_object_unref0 (self->priv->dao);
	_g_object_unref0 (self->priv->models);
	G_OBJECT_CLASS (gnomecook_model_model_parent_class)->finalize (obj);
}


GType gnomecook_model_model_get_type (void) {
	static volatile gsize gnomecook_model_model_type_id__volatile = 0;
	if (g_once_init_enter (&gnomecook_model_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (gnomecookmodelModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomecook_model_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (gnomecookmodelModel), 0, (GInstanceInitFunc) gnomecook_model_model_instance_init, NULL };
		GType gnomecook_model_model_type_id;
		gnomecook_model_model_type_id = g_type_register_static (G_TYPE_OBJECT, "gnomecookmodelModel", &g_define_type_info, 0);
		g_once_init_leave (&gnomecook_model_model_type_id__volatile, gnomecook_model_model_type_id);
	}
	return gnomecook_model_model_type_id__volatile;
}




