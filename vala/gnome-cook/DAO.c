/* DAO.c generated by valac 0.10.0, the Vala compiler
 * generated from DAO.vala, do not modify */

/* DAO.vala
 *
 * Copyright (C) 2010  Joel Marty
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *  
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Author:
 * 	Joel Marty <10093745@brookes.ac.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <sqlite3.h>
#include <glib/gstdio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define GNOMECOOK_DAO_TYPE_DAO_INTERFACE (gnomecook_dao_dao_interface_get_type ())
#define GNOMECOOK_DAO_DAO_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE, gnomecookDAODAOInterface))
#define GNOMECOOK_DAO_IS_DAO_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE))
#define GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMECOOK_DAO_TYPE_DAO_INTERFACE, gnomecookDAODAOInterfaceIface))

typedef struct _gnomecookDAODAOInterface gnomecookDAODAOInterface;
typedef struct _gnomecookDAODAOInterfaceIface gnomecookDAODAOInterfaceIface;
#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define GNOMECOOK_DAO_TYPE_MEAL_DAO (gnomecook_dao_meal_dao_get_type ())
#define GNOMECOOK_DAO_MEAL_DAO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAO))
#define GNOMECOOK_DAO_MEAL_DAO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAOClass))
#define GNOMECOOK_DAO_IS_MEAL_DAO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO))
#define GNOMECOOK_DAO_IS_MEAL_DAO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMECOOK_DAO_TYPE_MEAL_DAO))
#define GNOMECOOK_DAO_MEAL_DAO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAOClass))

typedef struct _gnomecookDAOMealDAO gnomecookDAOMealDAO;
typedef struct _gnomecookDAOMealDAOClass gnomecookDAOMealDAOClass;
typedef struct _gnomecookDAOMealDAOPrivate gnomecookDAOMealDAOPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define GNOMECOOK_DOMAIN_TYPE_MEAL (gnomecook_domain_meal_get_type ())
#define GNOMECOOK_DOMAIN_MEAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMeal))
#define GNOMECOOK_DOMAIN_MEAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMealClass))
#define GNOMECOOK_DOMAIN_IS_MEAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL))
#define GNOMECOOK_DOMAIN_IS_MEAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMECOOK_DOMAIN_TYPE_MEAL))
#define GNOMECOOK_DOMAIN_MEAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMECOOK_DOMAIN_TYPE_MEAL, gnomecookDomainMealClass))

typedef struct _gnomecookDomainMeal gnomecookDomainMeal;
typedef struct _gnomecookDomainMealClass gnomecookDomainMealClass;
#define _sqlite3_finalize0(var) ((var == NULL) ? NULL : (var = (sqlite3_finalize (var), NULL)))

typedef enum  {
	GNOMECOOK_DAO_DAO_ERROR_E_OPEN,
	GNOMECOOK_DAO_DAO_ERROR_E_SQL,
	GNOMECOOK_DAO_DAO_ERROR_E_TYPE
} gnomecookDAODAOError;
#define GNOMECOOK_DAO_DAO_ERROR gnomecook_dao_dao_error_quark ()
struct _gnomecookDAODAOInterfaceIface {
	GTypeInterface parent_iface;
	gpointer (*get_one) (gnomecookDAODAOInterface* self, gint64 id, GError** error);
	GeeList* (*get_all) (gnomecookDAODAOInterface* self, GError** error);
	void (*add) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
	void (*update) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
	void (*del) (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
};

struct _gnomecookDAOMealDAO {
	GObject parent_instance;
	gnomecookDAOMealDAOPrivate * priv;
};

struct _gnomecookDAOMealDAOClass {
	GObjectClass parent_class;
};

struct _gnomecookDAOMealDAOPrivate {
	sqlite3* _db;
};


static gnomecookDAOMealDAO* gnomecook_dao_meal_dao__instance;
static gnomecookDAOMealDAO* gnomecook_dao_meal_dao__instance = NULL;
static gpointer gnomecook_dao_meal_dao_parent_class = NULL;
static gnomecookDAODAOInterfaceIface* gnomecook_dao_meal_dao_gnomecook_dao_dao_interface_parent_iface = NULL;

GQuark gnomecook_dao_dao_error_quark (void);
GType gnomecook_dao_dao_interface_get_type (void) G_GNUC_CONST;
sqlite3* gnomecook_dao_dao_interface_connect (GError** error);
gpointer gnomecook_dao_dao_interface_get_one (gnomecookDAODAOInterface* self, gint64 id, GError** error);
GeeList* gnomecook_dao_dao_interface_get_all (gnomecookDAODAOInterface* self, GError** error);
void gnomecook_dao_dao_interface_add (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
void gnomecook_dao_dao_interface_update (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
void gnomecook_dao_dao_interface_del (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error);
GType gnomecook_dao_meal_dao_get_type (void) G_GNUC_CONST;
#define GNOMECOOK_DAO_MEAL_DAO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMECOOK_DAO_TYPE_MEAL_DAO, gnomecookDAOMealDAOPrivate))
enum  {
	GNOMECOOK_DAO_MEAL_DAO_DUMMY_PROPERTY
};
gnomecookDAOMealDAO* gnomecook_dao_meal_dao_get_instance (GError** error);
static gnomecookDAOMealDAO* gnomecook_dao_meal_dao_new (GError** error);
static gnomecookDAOMealDAO* gnomecook_dao_meal_dao_construct (GType object_type, GError** error);
GType gnomecook_domain_meal_get_type (void) G_GNUC_CONST;
static gnomecookDomainMeal* gnomecook_dao_meal_dao_real_get_one (gnomecookDAODAOInterface* base, gint64 id, GError** error);
gnomecookDomainMeal* gnomecook_domain_meal_new (void);
gnomecookDomainMeal* gnomecook_domain_meal_construct (GType object_type);
void gnomecook_domain_meal_set_id (gnomecookDomainMeal* self, gint64 value);
void gnomecook_domain_meal_set_name (gnomecookDomainMeal* self, const char* value);
void gnomecook_domain_meal_set_cooking_time (gnomecookDomainMeal* self, double value);
void gnomecook_domain_meal_set_instructions (gnomecookDomainMeal* self, const char* value);
void gnomecook_domain_meal_set_rating (gnomecookDomainMeal* self, double value);
void gnomecook_domain_meal_set_ingredients (gnomecookDomainMeal* self, const char* value);
static GeeList* gnomecook_dao_meal_dao_real_get_all (gnomecookDAODAOInterface* base, GError** error);
static void gnomecook_dao_meal_dao_real_add (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error);
const char* gnomecook_domain_meal_get_name (gnomecookDomainMeal* self);
double gnomecook_domain_meal_get_cooking_time (gnomecookDomainMeal* self);
const char* gnomecook_domain_meal_get_instructions (gnomecookDomainMeal* self);
double gnomecook_domain_meal_get_rating (gnomecookDomainMeal* self);
const char* gnomecook_domain_meal_get_ingredients (gnomecookDomainMeal* self);
static void gnomecook_dao_meal_dao_real_update (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error);
gint64 gnomecook_domain_meal_get_id (gnomecookDomainMeal* self);
static void gnomecook_dao_meal_dao_real_del (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error);
static void gnomecook_dao_meal_dao_finalize (GObject* obj);



GQuark gnomecook_dao_dao_error_quark (void) {
	return g_quark_from_static_string ("gnomecook_dao_dao_error-quark");
}


#line 38 "DAO.vala"
sqlite3* gnomecook_dao_dao_interface_connect (GError** error) {
#line 152 "DAO.c"
	sqlite3* result = NULL;
	sqlite3* _db;
	gint rc;
	GError * _inner_error_ = NULL;
#line 39 "DAO.vala"
	_db = NULL;
#line 40 "DAO.vala"
	rc = 0;
#line 42 "DAO.vala"
	if (!g_file_test ("data/cook.db", G_FILE_TEST_IS_REGULAR)) {
#line 163 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN, "Database not found");
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_close0 (_db);
				return NULL;
			} else {
				_sqlite3_close0 (_db);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		sqlite3* _tmp0_ = NULL;
		gint _tmp1_;
		sqlite3* _tmp2_;
#line 45 "DAO.vala"
		rc = (_tmp1_ = sqlite3_open_v2 ("data/cook.db", &_tmp0_, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL), _db = (_tmp2_ = _tmp0_, _sqlite3_close0 (_db), _tmp2_), _tmp1_);
#line 183 "DAO.c"
	}
#line 47 "DAO.vala"
	if (rc != SQLITE_OK) {
#line 187 "DAO.c"
		char* _tmp3_;
		char* _tmp4_;
		char* _tmp5_;
		char* _tmp6_;
		GError* _tmp7_;
		_inner_error_ = (_tmp7_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN, _tmp6_ = g_strconcat (_tmp5_ = g_strconcat (_tmp4_ = g_strconcat ("Error opening the database, code is ", _tmp3_ = g_strdup_printf ("%i", rc), NULL), ": ", NULL), sqlite3_errmsg (_db), NULL)), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _g_free0 (_tmp3_), _tmp7_);
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_close0 (_db);
				return NULL;
			} else {
				_sqlite3_close0 (_db);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = _db;
#line 50 "DAO.vala"
	return result;
#line 210 "DAO.c"
}


gpointer gnomecook_dao_dao_interface_get_one (gnomecookDAODAOInterface* self, gint64 id, GError** error) {
	return GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE (self)->get_one (self, id, error);
}


GeeList* gnomecook_dao_dao_interface_get_all (gnomecookDAODAOInterface* self, GError** error) {
	return GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE (self)->get_all (self, error);
}


void gnomecook_dao_dao_interface_add (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error) {
	GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE (self)->add (self, obj, error);
}


void gnomecook_dao_dao_interface_update (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error) {
	GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE (self)->update (self, obj, error);
}


void gnomecook_dao_dao_interface_del (gnomecookDAODAOInterface* self, gconstpointer obj, GError** error) {
	GNOMECOOK_DAO_DAO_INTERFACE_GET_INTERFACE (self)->del (self, obj, error);
}


static void gnomecook_dao_dao_interface_base_init (gnomecookDAODAOInterfaceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType gnomecook_dao_dao_interface_get_type (void) {
	static volatile gsize gnomecook_dao_dao_interface_type_id__volatile = 0;
	if (g_once_init_enter (&gnomecook_dao_dao_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (gnomecookDAODAOInterfaceIface), (GBaseInitFunc) gnomecook_dao_dao_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType gnomecook_dao_dao_interface_type_id;
		gnomecook_dao_dao_interface_type_id = g_type_register_static (G_TYPE_INTERFACE, "gnomecookDAODAOInterface", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (gnomecook_dao_dao_interface_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&gnomecook_dao_dao_interface_type_id__volatile, gnomecook_dao_dao_interface_type_id);
	}
	return gnomecook_dao_dao_interface_type_id__volatile;
}


static gpointer _g_error_copy0 (gpointer self) {
	return self ? g_error_copy (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 69 "DAO.vala"
gnomecookDAOMealDAO* gnomecook_dao_meal_dao_get_instance (GError** error) {
#line 272 "DAO.c"
	gnomecookDAOMealDAO* result = NULL;
	GError * _inner_error_ = NULL;
#line 70 "DAO.vala"
	g_debug ("DAO.vala:70: MealDAO.get_instance()");
#line 72 "DAO.vala"
	if (gnomecook_dao_meal_dao__instance == NULL) {
#line 279 "DAO.c"
		{
			gnomecookDAOMealDAO* _tmp0_;
			gnomecookDAOMealDAO* _tmp1_;
#line 74 "DAO.vala"
			_tmp0_ = gnomecook_dao_meal_dao_new (&_inner_error_);
#line 285 "DAO.c"
			if (_inner_error_ != NULL) {
				if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN)) {
					goto __catch1_gnomecook_dao_dao_error_e_open;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
#line 74 "DAO.vala"
			gnomecook_dao_meal_dao__instance = (_tmp1_ = _tmp0_, _g_object_unref0 (gnomecook_dao_meal_dao__instance), _tmp1_);
#line 296 "DAO.c"
		}
		goto __finally1;
		__catch1_gnomecook_dao_dao_error_e_open:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				_inner_error_ = _g_error_copy0 (e);
				{
					_g_error_free0 (e);
					goto __finally1;
				}
				_g_error_free0 (e);
			}
		}
		__finally1:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = _g_object_ref0 (gnomecook_dao_meal_dao__instance);
#line 79 "DAO.vala"
	return result;
#line 328 "DAO.c"
}


#line 82 "DAO.vala"
static gnomecookDAOMealDAO* gnomecook_dao_meal_dao_construct (GType object_type, GError** error) {
#line 334 "DAO.c"
	gnomecookDAOMealDAO * self;
	GError * _inner_error_ = NULL;
#line 82 "DAO.vala"
	self = (gnomecookDAOMealDAO*) g_object_new (object_type, NULL);
#line 339 "DAO.c"
	{
		sqlite3* _tmp0_;
		sqlite3* _tmp1_;
#line 85 "DAO.vala"
		_tmp0_ = gnomecook_dao_dao_interface_connect (&_inner_error_);
#line 345 "DAO.c"
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_OPEN)) {
				goto __catch2_gnomecook_dao_dao_error_e_open;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
#line 85 "DAO.vala"
		self->priv->_db = (_tmp1_ = _tmp0_, _sqlite3_close0 (self->priv->_db), _tmp1_);
#line 356 "DAO.c"
	}
	goto __finally2;
	__catch2_gnomecook_dao_dao_error_e_open:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_inner_error_ = _g_error_copy0 (e);
			{
				_g_error_free0 (e);
				goto __finally2;
			}
			_g_error_free0 (e);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	return self;
}


#line 82 "DAO.vala"
static gnomecookDAOMealDAO* gnomecook_dao_meal_dao_new (GError** error) {
#line 82 "DAO.vala"
	return gnomecook_dao_meal_dao_construct (GNOMECOOK_DAO_TYPE_MEAL_DAO, error);
#line 393 "DAO.c"
}


#line 91 "DAO.vala"
static gnomecookDomainMeal* gnomecook_dao_meal_dao_real_get_one (gnomecookDAODAOInterface* base, gint64 id, GError** error) {
#line 399 "DAO.c"
	gnomecookDAOMealDAO * self;
	gnomecookDomainMeal* result = NULL;
	char* qry;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3_stmt* _tmp2_;
	gint res;
	gnomecookDomainMeal* m;
	GError * _inner_error_ = NULL;
	self = (gnomecookDAOMealDAO*) base;
#line 93 "DAO.vala"
	qry = g_strdup ("SELECT id, name, cooking_time, instructions, rating, ingredients " "FROM meals WHERE id = ?");
#line 413 "DAO.c"
	stmt = NULL;
#line 97 "DAO.vala"
	res = (_tmp1_ = sqlite3_prepare_v2 (self->priv->_db, qry, -1, &_tmp0_, NULL), stmt = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (stmt), _tmp2_), _tmp1_);
#line 99 "DAO.vala"
	sqlite3_bind_int64 (stmt, 1, id);
#line 100 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 102 "DAO.vala"
	res = sqlite3_step (stmt);
#line 103 "DAO.vala"
	if (res != SQLITE_ROW) {
#line 425 "DAO.c"
		char* _tmp3_;
		char* _tmp4_;
		char* _tmp5_;
		GError* _tmp6_;
		_inner_error_ = (_tmp6_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, _tmp5_ = g_strconcat (_tmp4_ = g_strconcat ("Fetching meal ", _tmp3_ = g_strdup_printf ("%" G_GINT64_FORMAT, id), NULL), " failed", NULL)), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _g_free0 (_tmp3_), _tmp6_);
		{
			if ((_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) || (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR)) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return NULL;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
#line 107 "DAO.vala"
	m = gnomecook_domain_meal_new ();
#line 109 "DAO.vala"
	gnomecook_domain_meal_set_id (m, sqlite3_column_int64 (stmt, 0));
#line 110 "DAO.vala"
	gnomecook_domain_meal_set_name (m, sqlite3_column_text (stmt, 1));
#line 111 "DAO.vala"
	gnomecook_domain_meal_set_cooking_time (m, sqlite3_value_double (sqlite3_column_value (stmt, 2)));
#line 112 "DAO.vala"
	gnomecook_domain_meal_set_instructions (m, sqlite3_column_text (stmt, 3));
#line 113 "DAO.vala"
	gnomecook_domain_meal_set_rating (m, sqlite3_value_double (sqlite3_column_value (stmt, 4)));
#line 114 "DAO.vala"
	gnomecook_domain_meal_set_ingredients (m, sqlite3_column_text (stmt, 5));
#line 460 "DAO.c"
	result = m;
	_sqlite3_finalize0 (stmt);
	_g_free0 (qry);
#line 116 "DAO.vala"
	return result;
#line 466 "DAO.c"
}


#line 119 "DAO.vala"
static GeeList* gnomecook_dao_meal_dao_real_get_all (gnomecookDAODAOInterface* base, GError** error) {
#line 472 "DAO.c"
	gnomecookDAOMealDAO * self;
	GeeList* result = NULL;
	char* qry;
	GeeList* meals;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3_stmt* _tmp2_;
	gint res;
	GError * _inner_error_ = NULL;
	self = (gnomecookDAOMealDAO*) base;
#line 121 "DAO.vala"
	qry = g_strdup ("SELECT id, name, cooking_time, instructions, rating, ingredients FROM " \
"meals;");
#line 122 "DAO.vala"
	meals = (GeeList*) gee_array_list_new (GNOMECOOK_DOMAIN_TYPE_MEAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
#line 488 "DAO.c"
	stmt = NULL;
#line 125 "DAO.vala"
	res = (_tmp1_ = sqlite3_prepare_v2 (self->priv->_db, qry, -1, &_tmp0_, NULL), stmt = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (stmt), _tmp2_), _tmp1_);
#line 126 "DAO.vala"
	if (res != SQLITE_OK) {
#line 494 "DAO.c"
		char* _tmp3_;
		GError* _tmp4_;
		_inner_error_ = (_tmp4_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, _tmp3_ = g_strconcat ("preparing statement: ", sqlite3_errmsg (self->priv->_db), NULL)), _g_free0 (_tmp3_), _tmp4_);
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_object_unref0 (meals);
				_g_free0 (qry);
				return NULL;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_object_unref0 (meals);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	{
		gboolean _tmp5_;
#line 129 "DAO.vala"
		_tmp5_ = TRUE;
#line 129 "DAO.vala"
		while (TRUE) {
#line 521 "DAO.c"
			gnomecookDomainMeal* m;
#line 129 "DAO.vala"
			if (!_tmp5_) {
#line 525 "DAO.c"
			}
#line 129 "DAO.vala"
			_tmp5_ = FALSE;
#line 130 "DAO.vala"
			res = sqlite3_step (stmt);
#line 131 "DAO.vala"
			if (res == SQLITE_DONE) {
#line 132 "DAO.vala"
				break;
#line 535 "DAO.c"
			} else {
#line 133 "DAO.vala"
				if (res != SQLITE_ROW) {
#line 539 "DAO.c"
					char* _tmp6_;
					GError* _tmp7_;
					_inner_error_ = (_tmp7_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, _tmp6_ = g_strconcat ("error fetching row:", sqlite3_errmsg (self->priv->_db), NULL)), _g_free0 (_tmp6_), _tmp7_);
					{
						if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
							g_propagate_error (error, _inner_error_);
							_sqlite3_finalize0 (stmt);
							_g_object_unref0 (meals);
							_g_free0 (qry);
							return NULL;
						} else {
							_sqlite3_finalize0 (stmt);
							_g_object_unref0 (meals);
							_g_free0 (qry);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
			}
#line 136 "DAO.vala"
			m = gnomecook_domain_meal_new ();
#line 138 "DAO.vala"
			gnomecook_domain_meal_set_id (m, sqlite3_column_int64 (stmt, 0));
#line 139 "DAO.vala"
			gnomecook_domain_meal_set_name (m, sqlite3_column_text (stmt, 1));
#line 140 "DAO.vala"
			gnomecook_domain_meal_set_cooking_time (m, sqlite3_value_double (sqlite3_column_value (stmt, 2)));
#line 141 "DAO.vala"
			gnomecook_domain_meal_set_instructions (m, sqlite3_column_text (stmt, 3));
#line 142 "DAO.vala"
			gnomecook_domain_meal_set_rating (m, sqlite3_value_double (sqlite3_column_value (stmt, 4)));
#line 143 "DAO.vala"
			gnomecook_domain_meal_set_ingredients (m, sqlite3_column_text (stmt, 5));
#line 145 "DAO.vala"
			gee_collection_add ((GeeCollection*) meals, m);
#line 577 "DAO.c"
			_g_object_unref0 (m);
		}
	}
	result = meals;
	_sqlite3_finalize0 (stmt);
	_g_free0 (qry);
#line 148 "DAO.vala"
	return result;
#line 586 "DAO.c"
}


#line 151 "DAO.vala"
static void gnomecook_dao_meal_dao_real_add (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error) {
#line 592 "DAO.c"
	gnomecookDAOMealDAO * self;
	char* qry;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3_stmt* _tmp2_;
	gint res;
	GError * _inner_error_ = NULL;
	self = (gnomecookDAOMealDAO*) base;
#line 151 "DAO.vala"
	g_return_if_fail (m != NULL);
#line 153 "DAO.vala"
	qry = g_strdup ("INSERT INTO meals " "(name, " "cooking_time, " "instructions, " "rating, " "ingredients) VALUES(?,?,?,?,?)");
#line 606 "DAO.c"
	stmt = NULL;
#line 162 "DAO.vala"
	res = (_tmp1_ = sqlite3_prepare_v2 (self->priv->_db, qry, -1, &_tmp0_, NULL), stmt = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (stmt), _tmp2_), _tmp1_);
#line 164 "DAO.vala"
	if (res != SQLITE_OK) {
#line 612 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
#line 167 "DAO.vala"
	res = sqlite3_bind_text (stmt, 1, g_strdup (gnomecook_domain_meal_get_name (m)), -1, g_free);
#line 168 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 169 "DAO.vala"
	res = sqlite3_bind_double (stmt, 2, gnomecook_domain_meal_get_cooking_time (m));
#line 170 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 171 "DAO.vala"
	res = sqlite3_bind_text (stmt, 3, g_strdup (gnomecook_domain_meal_get_instructions (m)), -1, g_free);
#line 172 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 173 "DAO.vala"
	res = sqlite3_bind_double (stmt, 4, gnomecook_domain_meal_get_rating (m));
#line 174 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 175 "DAO.vala"
	res = sqlite3_bind_text (stmt, 5, g_strdup (gnomecook_domain_meal_get_ingredients (m)), -1, g_free);
#line 176 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 178 "DAO.vala"
	res = sqlite3_step (stmt);
#line 180 "DAO.vala"
	if (res != SQLITE_DONE) {
#line 653 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	_sqlite3_finalize0 (stmt);
	_g_free0 (qry);
}


#line 185 "DAO.vala"
static void gnomecook_dao_meal_dao_real_update (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error) {
#line 677 "DAO.c"
	gnomecookDAOMealDAO * self;
	char* qry;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3_stmt* _tmp2_;
	gint res;
	GError * _inner_error_ = NULL;
	self = (gnomecookDAOMealDAO*) base;
#line 185 "DAO.vala"
	g_return_if_fail (m != NULL);
#line 187 "DAO.vala"
	qry = g_strdup ("UPDATE meals SET " "name = ?, " "cooking_time = ?, " "instructions = ?, " "rating = ?, " "ingredients = ? " "where id = ? ;");
#line 691 "DAO.c"
	stmt = NULL;
#line 197 "DAO.vala"
	res = (_tmp1_ = sqlite3_prepare_v2 (self->priv->_db, qry, -1, &_tmp0_, NULL), stmt = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (stmt), _tmp2_), _tmp1_);
#line 199 "DAO.vala"
	if (res != SQLITE_OK) {
#line 697 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
#line 202 "DAO.vala"
	res = sqlite3_bind_text (stmt, 1, g_strdup (gnomecook_domain_meal_get_name (m)), -1, g_free);
#line 203 "DAO.vala"
	res = sqlite3_bind_double (stmt, 2, gnomecook_domain_meal_get_cooking_time (m));
#line 204 "DAO.vala"
	res = sqlite3_bind_text (stmt, 3, g_strdup (gnomecook_domain_meal_get_instructions (m)), -1, g_free);
#line 205 "DAO.vala"
	res = sqlite3_bind_double (stmt, 4, gnomecook_domain_meal_get_rating (m));
#line 206 "DAO.vala"
	res = sqlite3_bind_text (stmt, 5, g_strdup (gnomecook_domain_meal_get_ingredients (m)), -1, g_free);
#line 207 "DAO.vala"
	res = sqlite3_bind_int64 (stmt, 6, gnomecook_domain_meal_get_id (m));
#line 209 "DAO.vala"
	res = sqlite3_step (stmt);
#line 211 "DAO.vala"
	if (res != SQLITE_DONE) {
#line 730 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	_sqlite3_finalize0 (stmt);
	_g_free0 (qry);
}


#line 215 "DAO.vala"
static void gnomecook_dao_meal_dao_real_del (gnomecookDAODAOInterface* base, gnomecookDomainMeal* m, GError** error) {
#line 754 "DAO.c"
	gnomecookDAOMealDAO * self;
	char* qry;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3_stmt* _tmp2_;
	gint res;
	GError * _inner_error_ = NULL;
	self = (gnomecookDAOMealDAO*) base;
#line 215 "DAO.vala"
	g_return_if_fail (m != NULL);
#line 217 "DAO.vala"
	qry = g_strdup ("DELETE FROM meals WHERE id = ?;");
#line 768 "DAO.c"
	stmt = NULL;
#line 221 "DAO.vala"
	res = (_tmp1_ = sqlite3_prepare_v2 (self->priv->_db, qry, -1, &_tmp0_, NULL), stmt = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (stmt), _tmp2_), _tmp1_);
#line 223 "DAO.vala"
	if (res != SQLITE_OK) {
#line 774 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
#line 226 "DAO.vala"
	res = sqlite3_bind_int64 (stmt, 1, gnomecook_domain_meal_get_id (m));
#line 227 "DAO.vala"
	g_assert (res == SQLITE_OK);
#line 229 "DAO.vala"
	res = sqlite3_step (stmt);
#line 231 "DAO.vala"
	if (res != SQLITE_DONE) {
#line 799 "DAO.c"
		_inner_error_ = g_error_new_literal (GNOMECOOK_DAO_DAO_ERROR, GNOMECOOK_DAO_DAO_ERROR_E_SQL, sqlite3_errmsg (self->priv->_db));
		{
			if (_inner_error_->domain == GNOMECOOK_DAO_DAO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				return;
			} else {
				_sqlite3_finalize0 (stmt);
				_g_free0 (qry);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	_sqlite3_finalize0 (stmt);
	_g_free0 (qry);
}


static void gnomecook_dao_meal_dao_class_init (gnomecookDAOMealDAOClass * klass) {
	gnomecook_dao_meal_dao_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (gnomecookDAOMealDAOPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnomecook_dao_meal_dao_finalize;
}


static void gnomecook_dao_meal_dao_gnomecook_dao_dao_interface_interface_init (gnomecookDAODAOInterfaceIface * iface) {
	gnomecook_dao_meal_dao_gnomecook_dao_dao_interface_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_one = gnomecook_dao_meal_dao_real_get_one;
	iface->get_all = gnomecook_dao_meal_dao_real_get_all;
	iface->add = gnomecook_dao_meal_dao_real_add;
	iface->update = gnomecook_dao_meal_dao_real_update;
	iface->del = gnomecook_dao_meal_dao_real_del;
}


static void gnomecook_dao_meal_dao_instance_init (gnomecookDAOMealDAO * self) {
	self->priv = GNOMECOOK_DAO_MEAL_DAO_GET_PRIVATE (self);
}


static void gnomecook_dao_meal_dao_finalize (GObject* obj) {
	gnomecookDAOMealDAO * self;
	self = GNOMECOOK_DAO_MEAL_DAO (obj);
	_sqlite3_close0 (self->priv->_db);
	G_OBJECT_CLASS (gnomecook_dao_meal_dao_parent_class)->finalize (obj);
}


GType gnomecook_dao_meal_dao_get_type (void) {
	static volatile gsize gnomecook_dao_meal_dao_type_id__volatile = 0;
	if (g_once_init_enter (&gnomecook_dao_meal_dao_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (gnomecookDAOMealDAOClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomecook_dao_meal_dao_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (gnomecookDAOMealDAO), 0, (GInstanceInitFunc) gnomecook_dao_meal_dao_instance_init, NULL };
		static const GInterfaceInfo gnomecook_dao_dao_interface_info = { (GInterfaceInitFunc) gnomecook_dao_meal_dao_gnomecook_dao_dao_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gnomecook_dao_meal_dao_type_id;
		gnomecook_dao_meal_dao_type_id = g_type_register_static (G_TYPE_OBJECT, "gnomecookDAOMealDAO", &g_define_type_info, 0);
		g_type_add_interface_static (gnomecook_dao_meal_dao_type_id, GNOMECOOK_DAO_TYPE_DAO_INTERFACE, &gnomecook_dao_dao_interface_info);
		g_once_init_leave (&gnomecook_dao_meal_dao_type_id__volatile, gnomecook_dao_meal_dao_type_id);
	}
	return gnomecook_dao_meal_dao_type_id__volatile;
}




